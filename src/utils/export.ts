import type { ExplainerResult, BugFinderResult, RefactorResult, CodeSmellResult, ComplexityResult, SecurityResult } from '@/types';

export function exportExplainerToMarkdown(result: ExplainerResult, _code: string, language: string): string {
  let markdown = `# Code Explanation Analysis\n\n`;
  markdown += `**Language:** ${language}\n\n`;
  markdown += `## Summary\n\n${result.summary}\n\n`;
  markdown += `## Line-by-Line Explanation\n\n`;
  
  result.explanations.forEach((exp) => {
    markdown += `### Line ${exp.lineNumber}\n\n`;
    markdown += `\`\`\`${language}\n${exp.code}\n\`\`\`\n\n`;
    markdown += `**What it does:** ${exp.explanation}\n\n`;
    markdown += `**Why:** ${exp.why}\n\n`;
    
    if (exp.issues && exp.issues.length > 0) {
      markdown += `**‚ö†Ô∏è Potential Issues:**\n`;
      exp.issues.forEach(issue => {
        markdown += `- ${issue}\n`;
      });
      markdown += `\n`;
    }
  });
  
  markdown += `\n---\n*Generated by CodeQuality on ${new Date().toLocaleString()}*\n`;
  return markdown;
}

export function exportExplainerToText(result: ExplainerResult, _code: string, language: string): string {
  let text = `CODE EXPLANATION ANALYSIS\n`;
  text += `${'='.repeat(50)}\n\n`;
  text += `Language: ${language}\n\n`;
  text += `SUMMARY\n${'-'.repeat(50)}\n${result.summary}\n\n`;
  text += `LINE-BY-LINE EXPLANATION\n${'-'.repeat(50)}\n\n`;
  
  result.explanations.forEach((exp) => {
    text += `Line ${exp.lineNumber}:\n`;
    text += `Code: ${exp.code}\n`;
    text += `What it does: ${exp.explanation}\n`;
    text += `Why: ${exp.why}\n`;
    
    if (exp.issues && exp.issues.length > 0) {
      text += `Potential Issues:\n`;
      exp.issues.forEach(issue => {
        text += `  - ${issue}\n`;
      });
    }
    text += `\n`;
  });
  
  text += `\n${'='.repeat(50)}\n`;
  text += `Generated by CodeQuality on ${new Date().toLocaleString()}\n`;
  return text;
}

export function exportBugsToMarkdown(result: BugFinderResult, _code: string, language: string): string {
  let markdown = `# Bug Analysis Report\n\n`;
  markdown += `**Language:** ${language}\n`;
  markdown += `**Total Issues:** ${result.totalCount}\n\n`;
  
  markdown += `## Severity Summary\n\n`;
  markdown += `| Severity | Count |\n`;
  markdown += `|----------|-------|\n`;
  markdown += `| üî¥ Critical | ${result.severitySummary.critical} |\n`;
  markdown += `| üü† High | ${result.severitySummary.high} |\n`;
  markdown += `| üü° Medium | ${result.severitySummary.medium} |\n`;
  markdown += `| üîµ Low | ${result.severitySummary.low} |\n\n`;
  
  markdown += `## Issues Found\n\n`;
  
  result.bugs.forEach((bug, index) => {
    const severityEmoji = {
      critical: 'üî¥',
      high: 'üü†',
      medium: 'üü°',
      low: 'üîµ'
    }[bug.severity];
    
    markdown += `### ${index + 1}. ${bug.description}\n\n`;
    markdown += `**${severityEmoji} Severity:** ${bug.severity.toUpperCase()}\n`;
    markdown += `**Line:** ${bug.lineNumber}\n`;
    markdown += `**Category:** ${bug.category}\n\n`;
    markdown += `**Explanation:** ${bug.explanation}\n\n`;
    markdown += `**Suggested Fix:**\n\`\`\`${language}\n${bug.suggestedFix}\n\`\`\`\n\n`;
  });
  
  markdown += `---\n*Generated by CodeQuality on ${new Date().toLocaleString()}*\n`;
  return markdown;
}

export function exportBugsToText(result: BugFinderResult, _code: string, language: string): string {
  let text = `BUG ANALYSIS REPORT\n`;
  text += `${'='.repeat(50)}\n\n`;
  text += `Language: ${language}\n`;
  text += `Total Issues: ${result.totalCount}\n\n`;
  
  text += `SEVERITY SUMMARY\n${'-'.repeat(50)}\n`;
  text += `Critical: ${result.severitySummary.critical}\n`;
  text += `High: ${result.severitySummary.high}\n`;
  text += `Medium: ${result.severitySummary.medium}\n`;
  text += `Low: ${result.severitySummary.low}\n\n`;
  
  text += `ISSUES FOUND\n${'-'.repeat(50)}\n\n`;
  
  result.bugs.forEach((bug, index) => {
    text += `${index + 1}. ${bug.description}\n`;
    text += `Severity: ${bug.severity.toUpperCase()}\n`;
    text += `Line: ${bug.lineNumber}\n`;
    text += `Category: ${bug.category}\n`;
    text += `Explanation: ${bug.explanation}\n`;
    text += `Suggested Fix:\n${bug.suggestedFix}\n\n`;
  });
  
  text += `${'='.repeat(50)}\n`;
  text += `Generated by CodeQuality on ${new Date().toLocaleString()}\n`;
  return text;
}

export function exportRefactoringToMarkdown(result: RefactorResult, _code: string, language: string): string {
  let markdown = `# Code Refactoring Analysis\n\n`;
  markdown += `**Language:** ${language}\n`;
  markdown += `**Overall Quality Score:** ${result.overallScore}/100\n\n`;
  
  markdown += `## Refactoring Suggestions\n\n`;
  
  result.suggestions.forEach((suggestion, index) => {
    const priorityEmoji = {
      high: 'üî¥',
      medium: 'üü°',
      low: 'üîµ'
    }[suggestion.priority];
    
    markdown += `### ${index + 1}. ${suggestion.title}\n\n`;
    markdown += `**${priorityEmoji} Priority:** ${suggestion.priority.toUpperCase()}\n`;
    markdown += `**Lines:** ${suggestion.lineNumbers.join(', ')}\n`;
    markdown += `**Impact:** ${suggestion.impact}\n\n`;
    markdown += `**Description:** ${suggestion.description}\n\n`;
    
    markdown += `**Benefits:**\n`;
    suggestion.benefits.forEach(benefit => {
      markdown += `- ${benefit}\n`;
    });
    markdown += `\n`;
    
    markdown += `**Before:**\n\`\`\`${language}\n${suggestion.before}\n\`\`\`\n\n`;
    markdown += `**After:**\n\`\`\`${language}\n${suggestion.after}\n\`\`\`\n\n`;
  });
  
  markdown += `---\n*Generated by CodeQuality on ${new Date().toLocaleString()}*\n`;
  return markdown;
}

export function exportRefactoringToText(result: RefactorResult, _code: string, language: string): string {
  let text = `CODE REFACTORING ANALYSIS\n`;
  text += `${'='.repeat(50)}\n\n`;
  text += `Language: ${language}\n`;
  text += `Overall Quality Score: ${result.overallScore}/100\n\n`;
  
  text += `REFACTORING SUGGESTIONS\n${'-'.repeat(50)}\n\n`;
  
  result.suggestions.forEach((suggestion, index) => {
    text += `${index + 1}. ${suggestion.title}\n`;
    text += `Priority: ${suggestion.priority.toUpperCase()}\n`;
    text += `Lines: ${suggestion.lineNumbers.join(', ')}\n`;
    text += `Impact: ${suggestion.impact}\n`;
    text += `Description: ${suggestion.description}\n\n`;
    
    text += `Benefits:\n`;
    suggestion.benefits.forEach(benefit => {
      text += `  - ${benefit}\n`;
    });
    text += `\n`;
    
    text += `Before:\n${suggestion.before}\n\n`;
    text += `After:\n${suggestion.after}\n\n`;
    text += `${'-'.repeat(50)}\n\n`;
  });
  
  text += `${'='.repeat(50)}\n`;
  text += `Generated by CodeQuality on ${new Date().toLocaleString()}\n`;
  return text;
}

export function exportSmellsToMarkdown(result: CodeSmellResult, _code: string, language: string): string {
  let markdown = `# Code Smell Analysis Report\n\n`;
  markdown += `**Language:** ${language}\n`;
  markdown += `**Total Smells:** ${result.totalCount}\n`;
  markdown += `**Overall Health Score:** ${result.overallHealthScore}/100\n\n`;
  
  markdown += `## Category Summary\n\n`;
  markdown += `| Category | Count |\n`;
  markdown += `|----------|-------|\n`;
  markdown += `| üî• Bloaters | ${result.categorySummary.bloaters} |\n`;
  markdown += `| ‚ö†Ô∏è OO Abusers | ${result.categorySummary['oo-abusers']} |\n`;
  markdown += `| ‚ö° Change Preventers | ${result.categorySummary['change-preventers']} |\n`;
  markdown += `| üì¶ Dispensables | ${result.categorySummary.dispensables} |\n`;
  markdown += `| üîó Couplers | ${result.categorySummary.couplers} |\n\n`;
  
  markdown += `## Code Smells Detected\n\n`;
  
  result.smells.forEach((smell, index) => {
    const categoryEmoji = {
      'bloaters': 'üî•',
      'oo-abusers': '‚ö†Ô∏è',
      'change-preventers': '‚ö°',
      'dispensables': 'üì¶',
      'couplers': 'üîó'
    }[smell.category];
    
    markdown += `### ${index + 1}. ${smell.title}\n\n`;
    markdown += `**${categoryEmoji} Category:** ${smell.category}\n`;
    markdown += `**Severity:** ${smell.severity}/10\n`;
    if (smell.lineNumbers.length > 0) {
      markdown += `**Lines:** ${smell.lineNumbers.join(', ')}\n`;
    }
    markdown += `\n**Description:** ${smell.description}\n\n`;
    markdown += `**Why This is a Problem:**\n${smell.explanation}\n\n`;
    markdown += `**How to Fix It:**\n${smell.remediation}\n\n`;
    
    if (smell.example) {
      markdown += `**Example:**\n\`\`\`${language}\n${smell.example}\n\`\`\`\n\n`;
    }
  });
  
  markdown += `---\n*Generated by CodeQuality on ${new Date().toLocaleString()}*\n`;
  return markdown;
}

export function exportSmellsToText(result: CodeSmellResult, _code: string, language: string): string {
  let text = `CODE SMELL ANALYSIS REPORT\n`;
  text += `${'='.repeat(50)}\n\n`;
  text += `Language: ${language}\n`;
  text += `Total Smells: ${result.totalCount}\n`;
  text += `Overall Health Score: ${result.overallHealthScore}/100\n\n`;
  
  text += `CATEGORY SUMMARY\n${'-'.repeat(50)}\n`;
  text += `Bloaters: ${result.categorySummary.bloaters}\n`;
  text += `OO Abusers: ${result.categorySummary['oo-abusers']}\n`;
  text += `Change Preventers: ${result.categorySummary['change-preventers']}\n`;
  text += `Dispensables: ${result.categorySummary.dispensables}\n`;
  text += `Couplers: ${result.categorySummary.couplers}\n\n`;
  
  text += `CODE SMELLS DETECTED\n${'-'.repeat(50)}\n\n`;
  
  result.smells.forEach((smell, index) => {
    text += `${index + 1}. ${smell.title}\n`;
    text += `Category: ${smell.category}\n`;
    text += `Severity: ${smell.severity}/10\n`;
    if (smell.lineNumbers.length > 0) {
      text += `Lines: ${smell.lineNumbers.join(', ')}\n`;
    }
    text += `Description: ${smell.description}\n`;
    text += `\nWhy This is a Problem:\n${smell.explanation}\n`;
    text += `\nHow to Fix It:\n${smell.remediation}\n`;
    
    if (smell.example) {
      text += `\nExample:\n${smell.example}\n`;
    }
    text += `\n${'-'.repeat(50)}\n\n`;
  });
  
  text += `${'='.repeat(50)}\n`;
  text += `Generated by CodeQuality on ${new Date().toLocaleString()}\n`;
  return text;
}

export function exportComplexityToMarkdown(result: ComplexityResult, _code: string, language: string): string {
  let markdown = `# Code Complexity Analysis\n\n`;
  markdown += `**Language:** ${language}\n\n`;
  
  const maintColor = result.maintainabilityIndex >= 80 ? 'üü¢' : 
                      result.maintainabilityIndex >= 60 ? 'üü°' : 
                      result.maintainabilityIndex >= 40 ? 'üü†' : 'üî¥';
  
  markdown += `## Maintainability Index: ${maintColor} ${result.maintainabilityIndex}/100\n\n`;
  
  markdown += `## Overall Metrics\n\n`;
  markdown += `| Metric | Value |\n`;
  markdown += `|--------|-------|\n`;
  markdown += `| Total Functions | ${result.overallMetrics.totalFunctions} |\n`;
  markdown += `| Complex Functions (>10) | ${result.overallMetrics.complexFunctions} |\n`;
  markdown += `| Avg Cyclomatic Complexity | ${result.overallMetrics.averageCyclomaticComplexity.toFixed(1)} |\n`;
  markdown += `| Avg Cognitive Complexity | ${result.overallMetrics.averageCognitiveComplexity.toFixed(1)} |\n`;
  markdown += `| Max Nesting Depth | ${result.overallMetrics.maxNestingDepth} |\n\n`;
  
  markdown += `## Function Analysis\n\n`;
  
  result.functions.forEach((func, index) => {
    const complexity = func.cyclomaticComplexity >= 20 ? 'üî¥ Very High' :
                      func.cyclomaticComplexity >= 10 ? 'üü† High' :
                      func.cyclomaticComplexity >= 5 ? 'üü° Medium' : 'üü¢ Low';
    
    markdown += `### ${index + 1}. \`${func.name}\` (Line ${func.lineNumber})\n\n`;
    markdown += `**Complexity:** ${complexity}\n\n`;
    markdown += `| Metric | Value |\n`;
    markdown += `|--------|-------|\n`;
    markdown += `| Cyclomatic Complexity | ${func.cyclomaticComplexity} |\n`;
    markdown += `| Cognitive Complexity | ${func.cognitiveComplexity} |\n`;
    markdown += `| Nesting Depth | ${func.nestingDepth} |\n`;
    markdown += `| Parameter Count | ${func.parameterCount} |\n`;
    markdown += `| Lines of Code | ${func.linesOfCode} |\n\n`;
    
    if (func.issues.length > 0) {
      markdown += `**‚ö†Ô∏è Issues:**\n`;
      func.issues.forEach(issue => {
        markdown += `- ${issue}\n`;
      });
      markdown += `\n`;
    }
  });
  
  if (result.recommendations.length > 0) {
    markdown += `## Recommendations\n\n`;
    result.recommendations.forEach((rec, index) => {
      markdown += `${index + 1}. ${rec}\n`;
    });
    markdown += `\n`;
  }
  
  markdown += `---\n*Generated by CodeQuality on ${new Date().toLocaleString()}*\n`;
  return markdown;
}

export function exportComplexityToText(result: ComplexityResult, _code: string, language: string): string {
  let text = `CODE COMPLEXITY ANALYSIS\n`;
  text += `${'='.repeat(50)}\n\n`;
  text += `Language: ${language}\n`;
  text += `Maintainability Index: ${result.maintainabilityIndex}/100\n\n`;
  
  text += `OVERALL METRICS\n${'-'.repeat(50)}\n`;
  text += `Total Functions: ${result.overallMetrics.totalFunctions}\n`;
  text += `Complex Functions (>10): ${result.overallMetrics.complexFunctions}\n`;
  text += `Avg Cyclomatic Complexity: ${result.overallMetrics.averageCyclomaticComplexity.toFixed(1)}\n`;
  text += `Avg Cognitive Complexity: ${result.overallMetrics.averageCognitiveComplexity.toFixed(1)}\n`;
  text += `Max Nesting Depth: ${result.overallMetrics.maxNestingDepth}\n\n`;
  
  text += `FUNCTION ANALYSIS\n${'-'.repeat(50)}\n\n`;
  
  result.functions.forEach((func, index) => {
    const complexity = func.cyclomaticComplexity >= 20 ? 'Very High' :
                      func.cyclomaticComplexity >= 10 ? 'High' :
                      func.cyclomaticComplexity >= 5 ? 'Medium' : 'Low';
    
    text += `${index + 1}. ${func.name} (Line ${func.lineNumber})\n`;
    text += `   Complexity: ${complexity}\n`;
    text += `   Cyclomatic Complexity: ${func.cyclomaticComplexity}\n`;
    text += `   Cognitive Complexity: ${func.cognitiveComplexity}\n`;
    text += `   Nesting Depth: ${func.nestingDepth}\n`;
    text += `   Parameter Count: ${func.parameterCount}\n`;
    text += `   Lines of Code: ${func.linesOfCode}\n`;
    
    if (func.issues.length > 0) {
      text += `   Issues:\n`;
      func.issues.forEach(issue => {
        text += `     - ${issue}\n`;
      });
    }
    text += `\n`;
  });
  
  if (result.recommendations.length > 0) {
    text += `RECOMMENDATIONS\n${'-'.repeat(50)}\n`;
    result.recommendations.forEach((rec, index) => {
      text += `${index + 1}. ${rec}\n`;
    });
    text += `\n`;
  }
  
  text += `${'='.repeat(50)}\n`;
  text += `Generated by CodeQuality on ${new Date().toLocaleString()}\n`;
  return text;
}

export function exportSecurityToMarkdown(result: SecurityResult, _code: string, language: string): string {
  let markdown = `# Security Vulnerability Report\n\n`;
  markdown += `**Language:** ${language}\n`;
  markdown += `**Total Vulnerabilities:** ${result.totalCount}\n`;
  markdown += `**Security Score:** ${result.securityScore}/100\n\n`;
  
  markdown += `## Severity Summary\n\n`;
  markdown += `| Severity | Count |\n`;
  markdown += `|----------|-------|\n`;
  markdown += `| üî¥ Critical | ${result.severitySummary.critical} |\n`;
  markdown += `| üü† High | ${result.severitySummary.high} |\n`;
  markdown += `| üü° Medium | ${result.severitySummary.medium} |\n`;
  markdown += `| üîµ Low | ${result.severitySummary.low} |\n`;
  markdown += `| ‚ÑπÔ∏è Info | ${result.severitySummary.info} |\n\n`;
  
  markdown += `## OWASP Categories\n\n`;
  const categoryLabels: Record<string, string> = {
    'injection': 'Injection',
    'broken-auth': 'Broken Authentication',
    'sensitive-data': 'Sensitive Data Exposure',
    'xxe': 'XML External Entities (XXE)',
    'broken-access': 'Broken Access Control',
    'security-misconfig': 'Security Misconfiguration',
    'xss': 'Cross-Site Scripting (XSS)',
    'insecure-deserialization': 'Insecure Deserialization',
    'vulnerable-components': 'Vulnerable Components',
    'logging-monitoring': 'Insufficient Logging & Monitoring',
  };
  
  Object.entries(result.categorySummary)
    .filter(([, count]) => count > 0)
    .forEach(([category, count]) => {
      markdown += `- **${categoryLabels[category]}:** ${count}\n`;
    });
  markdown += `\n`;
  
  markdown += `## Vulnerabilities\n\n`;
  
  result.vulnerabilities.forEach((vuln, index) => {
    const severityEmoji = {
      critical: 'üî¥',
      high: 'üü†',
      medium: 'üü°',
      low: 'üîµ',
      info: '‚ÑπÔ∏è'
    }[vuln.severity];
    
    markdown += `### ${index + 1}. ${vuln.title}\n\n`;
    markdown += `**${severityEmoji} Severity:** ${vuln.severity.toUpperCase()}\n`;
    markdown += `**Category:** ${categoryLabels[vuln.category]}\n`;
    markdown += `**Line:** ${vuln.lineNumber}\n`;
    if (vuln.cwe) {
      markdown += `**CWE:** ${vuln.cwe}\n`;
    }
    markdown += `\n**Description:** ${vuln.description}\n\n`;
    
    markdown += `**Vulnerable Code:**\n\`\`\`${language}\n${vuln.codeSnippet}\n\`\`\`\n\n`;
    
    markdown += `**Impact:** ${vuln.impact}\n\n`;
    
    markdown += `**Remediation:**\n${vuln.remediation}\n\n`;
    
    if (vuln.references.length > 0) {
      markdown += `**References:**\n`;
      vuln.references.forEach(ref => {
        markdown += `- ${ref}\n`;
      });
      markdown += `\n`;
    }
  });
  
  if (result.recommendations.length > 0) {
    markdown += `## Security Recommendations\n\n`;
    result.recommendations.forEach((rec, index) => {
      markdown += `${index + 1}. ${rec}\n`;
    });
    markdown += `\n`;
  }
  
  markdown += `---\n*Generated by CodeQuality on ${new Date().toLocaleString()}*\n`;
  return markdown;
}

export function exportSecurityToText(result: SecurityResult, _code: string, language: string): string {
  let text = `SECURITY VULNERABILITY REPORT\n`;
  text += `${'='.repeat(50)}\n\n`;
  text += `Language: ${language}\n`;
  text += `Total Vulnerabilities: ${result.totalCount}\n`;
  text += `Security Score: ${result.securityScore}/100\n\n`;
  
  text += `SEVERITY SUMMARY\n${'-'.repeat(50)}\n`;
  text += `Critical: ${result.severitySummary.critical}\n`;
  text += `High: ${result.severitySummary.high}\n`;
  text += `Medium: ${result.severitySummary.medium}\n`;
  text += `Low: ${result.severitySummary.low}\n`;
  text += `Info: ${result.severitySummary.info}\n\n`;
  
  text += `OWASP CATEGORIES\n${'-'.repeat(50)}\n`;
  const categoryLabels: Record<string, string> = {
    'injection': 'Injection',
    'broken-auth': 'Broken Authentication',
    'sensitive-data': 'Sensitive Data Exposure',
    'xxe': 'XML External Entities (XXE)',
    'broken-access': 'Broken Access Control',
    'security-misconfig': 'Security Misconfiguration',
    'xss': 'Cross-Site Scripting (XSS)',
    'insecure-deserialization': 'Insecure Deserialization',
    'vulnerable-components': 'Vulnerable Components',
    'logging-monitoring': 'Insufficient Logging & Monitoring',
  };
  
  Object.entries(result.categorySummary)
    .filter(([, count]) => count > 0)
    .forEach(([category, count]) => {
      text += `${categoryLabels[category]}: ${count}\n`;
    });
  text += `\n`;
  
  text += `VULNERABILITIES\n${'-'.repeat(50)}\n\n`;
  
  result.vulnerabilities.forEach((vuln, index) => {
    text += `${index + 1}. ${vuln.title}\n`;
    text += `   Severity: ${vuln.severity.toUpperCase()}\n`;
    text += `   Category: ${categoryLabels[vuln.category]}\n`;
    text += `   Line: ${vuln.lineNumber}\n`;
    if (vuln.cwe) {
      text += `   CWE: ${vuln.cwe}\n`;
    }
    text += `   Description: ${vuln.description}\n`;
    text += `   Vulnerable Code:\n   ${vuln.codeSnippet.split('\n').join('\n   ')}\n`;
    text += `   Impact: ${vuln.impact}\n`;
    text += `   Remediation: ${vuln.remediation.split('\n').join('\n   ')}\n`;
    
    if (vuln.references.length > 0) {
      text += `   References:\n`;
      vuln.references.forEach(ref => {
        text += `     - ${ref}\n`;
      });
    }
    text += `\n`;
  });
  
  if (result.recommendations.length > 0) {
    text += `SECURITY RECOMMENDATIONS\n${'-'.repeat(50)}\n`;
    result.recommendations.forEach((rec, index) => {
      text += `${index + 1}. ${rec}\n`;
    });
    text += `\n`;
  }
  
  text += `${'='.repeat(50)}\n`;
  text += `Generated by CodeQuality on ${new Date().toLocaleString()}\n`;
  return text;
}

export function downloadFile(content: string, filename: string, type: 'markdown' | 'text') {
  const mimeType = type === 'markdown' ? 'text/markdown' : 'text/plain';
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
